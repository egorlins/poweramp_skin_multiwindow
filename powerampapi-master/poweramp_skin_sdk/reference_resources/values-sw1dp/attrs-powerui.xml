<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (C) 2010-2018 Maksim Petrov

Redistribution and use in source and binary forms, with or without
modification, are permitted for themes, skins, widgets, plugins, applications and other software
which communicate with Poweramp music player application on Android platform.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->

<resources xmlns:tools="http://schemas.android.com/tools">
	<!-- Used in <include>, if true, no any error happens if android:layout doesn't exist (set to @null for that <include>) -->
	<attr name="optional" format="boolean"/>
	
	<!-- Optional styles. Applied based on user preferences. 
	     Styles for these attributes should be defined in main skin theme, but these styles will be applied only if appropriate option is set in Poweramp settings  -->
	<declare-styleable name="OptionalPoweruiStyles">
		<!-- Applied (over main theme style) when rating is enabled and set to stars -->
		<attr name="OptionRatingStars" format="reference"/>
		
		<!-- Applied (over main theme style) when rating is enabled and set to like/unlike thumbs -->
		<attr name="OptionRatingLikeUnlike" format="reference"/>
		
		<!-- Applied (over main theme style) when track counter is enabled -->
		<attr name="OptionCounter" format="reference"/>
	</declare-styleable>
	
	<!-- Styles always applied for activities / dialogs -->
	<declare-styleable name="PoweruiStyles">
		<!-- Base styles applied for any activity -->
		<attr name="BasePoweruiStyles" format="reference"/>
		
		<!-- Styles applied for main activity, includes top list widget, items, navbar, etc. styles -->
		<attr name="TopPoweruiStyles" format="reference"/>
	
		<!-- Forced styles for dialogs -->	
		<attr name="DialogForcedStyle"/>
	</declare-styleable>
	
	
	<!-- Base PowerList attributes. NOTE: main Poweramp list is a ListWidget (derived from PowerList) which has extra attributes (see ListWidget below) -->
	<declare-styleable name="PowerList">
		<!-- ListScroller view id. PowerList uses separate view as scrollbar -->
		<attr name="listScroller" format="reference"/>
		<!-- ListIndexer view id. PowerList uses separate indexer view (small popup with character for a-z scrolling) -->
		<attr name="listIndexer" format="reference"/>
		
		<attr name="moveableToolbar" format="reference"/><!-- Id of the toolbar which can be moved by list on scroll -->
		<attr name="moveableToolbarExtraStates" format="boolean"/><!-- If true, PowerList will set state w:state_toolbar_in_header for NavBar and NavBarButtons drawables when toolbar is over header -->
		<attr name="moveableToolbarAnchor">
			<enum name="fixedTop" value="0"/><!-- Toolbar always on top, doesn't move (also should be set in xml layout as top aligned) -->
			<enum name="top" value="1"/><!-- Toolbar moves away top on scroll (also should be set in xml layout as top aligned) -->
			<enum name="bottom" value="2"/><!-- Toolbar moves away bottom on scroll (also should be set in xml layout as bottom aligned) -->
			<enum name="fixedBottom" value="3"/><!-- Toolbar always on bottom, doesn't move (also should be set in xml layout as bottom aligned) -->
		</attr>
		
		<!-- Space to reserve for moveable toobar on bottom. Should be large enough so toolbar doesn't overlap last item -->
		<attr name="bottomReservedSpace" format="dimension"/>

		<!-- Space to reserve for selection bar on bottom. Should be large enough so selection doesn't overlap last item -->
		<attr name="selectionBottomReservedSpace" format="dimension"/>
		
		<attr name="android:colorEdgeEffect"/><!-- Defines overshoot edge effect color -->
	</declare-styleable>
	

	<!-- Main Poweramp list, i.e. main screen AA and all the Library lists and Library itself. 
		 NOTE: derived from PowerList - accepts PowerList attributes as well -->
	<declare-styleable name="ListWidget">
		<!-- ListWidget popup menu animation time -->
		<attr name="popupEnterAnimTime" format="integer"/><!-- ms -->
		<!-- ListWidget popup menu animation time -->
		<attr name="popupExitAnimTime" format="integer"/><!-- ms -->
		<attr name="menuPlaceholder" format="reference"/><!-- Some top level MenuHelper-enabled layout (poped-out item transformed into menu and attached there) -->
		
		<!-- Animation time between AA states (playing/paused) -->
		<attr name="preferedAAAnimTime" format="integer"/><!-- ms -->
		
		<!-- Controls AA blur background --> 
		<attr name="listMilkMode" format="integer">
			<flag name="none" value="0"/><!-- No any AA images are applied to background -->
			<flag name="mainAA" value="1"/><!-- Default. AA from main screen is applied to background --> 
			<flag name="listHeader" value="2"/><!-- AA from list headers is applied -->
		</attr>
		
		<!-- Milk (visualization) AA widget id --> 
		<attr name="listMilkAA" format="reference"/>
		
		<!-- Number of styles to apply to list internals -->
		<attr name="listSubstyle" format="reference"/>
		
		<!-- Automaticaly set top padding and add to bottomReservedSpace from status bar or/and android navigation bar.
			 NOTE: only top padding is modified for statusBar and bottomReservedSpace for navigationBar
		 -->
		<attr name="offsetWindowInsets">
			<flag name="none" value="0"/>
			<flag name="statusBar" value="0x1"/>
			<flag name="navigationBar" value="0x2"/>
		</attr>
	</declare-styleable>
	<!-- NOTE: see attrs-player.xml for ListSubstyle -->
	
	<declare-styleable name="Waveseek">
		<!-- Defines waveseek layout -->
		<attr name="waveLayout" format="integer">
			<enum name="scrollable" value="0"/><!-- Waveseek can be dragged with swipes -->
			<enum name="fixed" value="1"/><!-- Waveseek can't be dragged, progress follows touch -->
		</attr>
	
		<!-- Used only in layout=scrollable mode. Ignored in layout=fixed mode -->
		<attr name="barWidth" format="dimension|enum">
			<enum name="auto" value="-1"/><!-- If auto, matches barBitmap bitmap width -->
		</attr>
		
		<!-- Used for both layout modes. Can be a percentage of barWidth for layut=scrollable -->
		<attr name="barSpacing" format="dimension|fraction"/>
	
		<!-- 
			Defines number of bars in waveseek. The actual wave data set to the Waveseek by Poweramp may be of different size. Waveseek resamples
			incoming data to match numBars.
			
			For layout=fixed mode, this together with barSpacing defines width of bars. 
		 -->
		<attr name="numBars" format="integer"/>
		
		<!-- Minumum bar height. NOTE: min bar height can't be less than largest *barBitmap* width -->
		<attr name="minBarHeight" format="dimension"/>
		
		<!-- 
			Waveseek can draw either simple and fast bars with background and border or drawables 
		 	To the left is elapsedBar* bars/drawables, to the right - just bar*.
		 	If divisor is >=0%, then 2 bars/drawables are drawn - top and bottom. 
		 	Bottom bar is drawn with barColor2/elapsedBarColor2/barDrawable2/elapsedBarDrawable2.
		 	
		 	Center bar is split under cursor (even if cursor doesn't exist) - indicating the seek position.
		-->
			
		<!-- The divisor (empty space) position between top and bottom bars. If < 0%, then just one set of bars drawn --> 
		<attr name="divisor" format="fraction"/>
		<!-- The divisor size (size of the empty space between top and bottom bars) -->
		<attr name="divisorSize" format="dimension"/>
		
		
		<!-- NOTE: bar/elapsedBarColor*, bar/elapsedBarDrawable* / stroke are not used now due to issues on some Android devices. Instead raw bitmaps are used. 
			 See bar/elaspedBarBitmap* for details --> 
		<attr name="barColor" format="color|reference"/><!-- NOTE: not used -->
		<attr name="barColor2" format="color|reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarColor" format="color|reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarColor2" format="color|reference"/><!-- NOTE: not used -->
		<attr name="barStrokeColor" format="color|reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarStrokeColor" format="color|reference"/><!-- NOTE: not used -->
		<!-- If both barDrawable & elapsedBarDrawable are defined, then drawables are drawn, otherwise - bars -->
		<attr name="barDrawable" format="reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarDrawable" format="reference"/><!-- NOTE: not used -->
		<attr name="barDrawable2" format="reference"/><!-- NOTE: not used -->
		<attr name="elapsedBarDrawable2" format="reference"/><!-- NOTE: not used -->
		<!-- If non-zero, rounded corners applied to bars -->
		<attr name="barRoundedCorners" format="dimension"/><!-- NOTE: not used -->
		<attr name="stroke" format="dimension"/><!-- NOTE: not used -->
					
		<!-- NOTE: barBitmap/elapsedBarBitmap/barBitmap2/elapsedBarBitmap2 are specifically crafted bitmaps. Height of the bitmap should be >= width of the bitmap.
			 Bitmap is stretched in a way similar to 9-patch images, but only 3 "patches" used - top, middle, bottom.
			 Top is unstretched, height=width*0.5, bottom is unstretched, height=width*0.5 and reset is stretched middle.
			 
			 This is required as accross Android devices, many can't render 9-patch images reliable and fast, others can't reliable
			 render e.g. RoundRect shapes or other Drawables, thus, the approach with the raw Bitmaps is used here -->

		<!-- Non-yet-elapsed bar (to the right of playing point) --> 			 
		<attr name="barBitmap" format="reference"/>
		<!-- Elapsed bar (to the left of playing point) -->
		<attr name="elapsedBarBitmap" format="reference"/>
		<!-- Optiponal non-yet-elapsed bar (to the right of playing point) - bottom part -->
		<attr name="barBitmap2" format="reference"/>
		<!-- Optiponal elapsed bar (to the left of playing point) - bottom part -->
		<attr name="elapsedBarBitmap2" format="reference"/>		
			
		<!-- Used only in layout=fixed mode. Cursor position in percent of Waveseek width. 50%=center -->
		<attr name="cursorPosition" format="fraction"/>
		<!-- Used only in layout=fixed mode. Cursor absolute offset from cursorPosition -->
		<attr name="cursorOffset" format="dimension"/>
		
		<!-- Cursor activation animation -->
		<attr name="cursorAnimator" format="reference"/>

		<!-- Used only in layout=fixed mode. Default=true. If true, elapsed bars are redrawn immediately on any scroll, otherwise they delayed until scroll is finished -->
		<attr name="cursorBgFastTracking" format="boolean"/><!-- NOTE: not used -->
		
		<!-- If set, all bars will have this value. Useful for emulating "usual" seekbar -->
		<attr name="forceValue" format="float"/>
		
		<!-- Used only for layout=scroll. Default=true. If true, leftmost/rightmost bars are gradually faded out/in -->
		<attr name="fadeSidebars" format="boolean"/>

		<!-- Time for data change animation in ms -->
		<attr name="dataAnimTime" format="integer"/>
		<!-- Time for data change animation when no incoming data exists (to small line) in ms -->
		<attr name="noDataAnimTime" format="integer"/>
		
		<!-- Waveseek supports style "enabled" attribute (not supported by Android views by default). If set to false, waveseek functionality will be completely disabled -->
		<attr name="android:enabled"/>
	</declare-styleable>
	
	
	<!-- Scene params is a pseudo-view-tag (xml tag without actual view) which defines attributes for one or multiple scenes -->
	<declare-styleable name="SceneParams">
		<!-- If visibility is missing from given SceneParams, visibility is not changed -->
		<attr name="android:visibility"/>
		
		<!-- NOTE: manipulating visibility, alpha + StateAnim alpha is hard, and some scenarios may not work properly due to conflicting or overlapping alpha values --> 
	
		<!-- If alpha is missing from given SceneParams, alpha=1.0 is assumed -->
		<attr name="android:alpha"/>

		<!-- Uniform scale. Separate scaleX/Y are not supported.
			 If scale is missing from given ScenePArams, scale=1.0 is assumed -->
		<attr name="scale" format="float"/>
		
		<!-- Elevation is apply with "jump", as animated elevation change has large overhead. 
			 Appropriate outline provider, etc. valid elevation properties should be set on view.
			 If elevation is missing from given SceneParams, elevation value is kept as is.
			 Due to high overhead for elevation change, this property behavior, thus, differs from other SceneParams attributes like scale or alpha) -->
		<attr name="android:elevation"/>
		
		<!-- Optional attribute, if missing, SceneParams is attached to previous view -->
		<attr name="forId" format="reference|integer">
			<!-- NOTE: parent generally won't work when SceneParams is put into same XML layout which defines "parent", as during XML inflation,
				 that "parent" is not yet attached to upper parent, thus, it's not possible to create layout params for it, thus, not possible
				 to create SceneParams.
				 "parent" is used for loadable / merged XML layouts, when extra SceneParams should be added to parent view, where XML is added to
			--> 
			<enum name="parent" value="0"/>
			<!-- These SceneParams is for RootView (window top view group). Very special case, used e.g. for dialogs -->
			<enum name="root" value="-1"/>
		</attr>
		
		<!-- Target scene id which this SceneParams is for -->
		<attr name="scene" format="reference|integer">
			<!-- NOTE: scene can be set to defaultScene, so that will redefine the default scene (or update, if baseScene="defaultScene" is used 
				 Only first "scene" attribute supports that -->
			<enum name="defaultScene" value="0"/>
		</attr>
		<attr name="scene_2" format="reference"/><!-- valid only if scene exists in tag -->
		<attr name="scene_3" format="reference"/><!-- valid only if scene_2 exists in tag -->
		<attr name="scene_4" format="reference"/><!-- valid only if scene_3 exists in tag -->
		<attr name="scene_5" format="reference"/><!-- valid only if scene_4 exists in tag -->
		<attr name="scene_6" format="reference"/><!-- valid only if scene_5 exists in tag -->
		
		<!-- Base scene we copy all the properties from. Usually, using baseScene is better VS using parent styles, as
			 parent styles still require full parsing and processing, and baseScene just copies base scene values -->
		<attr name="baseScene" format="reference|integer">
			<enum name="defaultScene" value="0"/>
		</attr>
		
		<!-- NOTE: placed here for technical reasons to detect if layout params exist for given scene params.
			 If layout_width exists in attributes, we assume layout is set for this scene params, otherwise no layout is applied per this scene params -->
		<attr name="android:layout_width"/>
		
		<!-- Defines point during transition when target view is re-layout. Layout is a costly operation for most views -->
		<attr name="recalcChildren" format="fraction|integer">
			<!-- Initial child layout used for while transition until end (jumps in the end) -->
			<enum name="on_end" value="0" /><!-- Sync with SceneParams --> 
			
			<!-- Final child layout used for whole transition (jumps in the beggining) -->
			<enum name="on_start" value="1" /><!-- Sync with SceneParams -->
			 
			<!-- Dynamically recalculate layout of children, can be slow -->
			<enum name="dynamic" value="2" /><!-- Sync with SceneParams -->
		</attr>
		
		<!-- Default is true. Used for disabling existing scene, e.g. _tag_scene_zero -->
		<attr name="applyScene" format="boolean"/>
		
		<!-- Default is false for non-zero/default scene and true for zero/default scene. If true, per view params will be applied for this scene (if supported by view) -->
		<attr name="applyViewParams" format="boolean"/> 
		
		<!-- Default is false. If true, visibility will be applied immediately, without alpha transition. Good for cases when view should not fade at all -->
		<attr name="jumpVisibility" format="boolean"/>
		
		<!-- Apply scene params even if view is gone in both (from/to) scenes. Useful for views which are force-hidden by code, but still should differ in scenes -->
		<attr name="applyEvenIfGone" format="boolean"/>
	</declare-styleable>
	
	
	<!-- StateAnim is pseudo-view-tag which defines animation attribures, orthogonal to Scene animated params, used for small temporary transforms -->
	<declare-styleable name="StateAnimParams">
		<!-- Target view id -->
		<attr name="forId"/>
		<!-- State animation id -->
		<attr name="stateAnim" format="reference" />
		<!-- State animation id, valid if stateAnim is defined -->
		<attr name="stateAnim_2" format="reference" />
		<!-- State animation id, valid if stateAnim_2 is defined -->
		<attr name="stateAnim_3" format="reference" />
		<!-- State animation id, valid if stateAnim_3 is defined -->
		<attr name="stateAnim_4" format="reference" />

		<!-- Duration in ms -->		
		<attr name="android:duration"/>
		
		<!-- Target alpha. NOTE: if view is also transitioned by SceneParams with alpha, SceneParams alpha make take priority in some cases -->
		<attr name="android:alpha"/>
		<!-- Sets both scaleX and scaleY to same value. Has priority over separate scaleX/Y values -->
		<attr name="scale"/>
		<!-- Other params, animating the standard Android view transform properties -->
		<attr name="android:scaleX"/>
		<attr name="android:scaleY"/>
		<attr name="android:translationX"/>
		<attr name="android:translationY"/>
		<attr name="android:rotation"/>
		<attr name="android:rotationX"/>
		<attr name="android:rotationY"/>
	</declare-styleable>
	
	<!-- Used internally -->	
	<declare-styleable name="ViewTag">
		<attr name="android:id" />
		<attr name="android:value" />
	</declare-styleable>
	
	<!-- Used internally -->
	<declare-styleable name="Include">
		<attr name="android:id" />
		<attr name="android:visibility" />
		<attr name="android:layout_width"/>
	</declare-styleable>
	
	<!-- Used internally -->
	<!-- NOTE: shared by various controls and TextUtils -->
	<declare-styleable name="TextProps">
		<attr name="android:text"/>	
		<attr name="android:gravity"/>
		<attr name="android:textSize"/>
		<attr name="android:textColor"/>
		<attr name="android:textStyle"/>
		<attr name="android:textAppearance"/>
		<attr name="android:fontFamily" />
		<attr name="android:typeface" />
	</declare-styleable>
	
	<!-- Simple view which applies disabledAlpha when disabled -->
	<declare-styleable name="AlphaDisabledView">
		<!-- Defines the disabled alpha value -->	
		<attr name="android:disabledAlpha"/>
	</declare-styleable>
	
	<!-- FastTextView is TextView/Button/ImageButton replacement, which is designed for layout and drawing performance. Used for static text, labels, text with icons,
		 and just icons (+ few derived classes e.g. for checkboxes)
		 
		 This is, in some parts, very limited widget, esp. compared to full blown TextView, but it's fast:
		 - it doesn't use Android text layout code
		 - it doesn't support Spanned text 
		 - it doesn't support RTL
		 - it has limited drawable support (just one drawable. Can be positioned to the left, right or top)
		 
		 Nevertheless, additional features are:
		 - support for line drawables (per line text background, independent from general view background)
		 - support for additional SceneParams parameters: text color, max lines, drawable, line background, background 

		 Paddings:
		 NOTE: fast text padding processing (with drawable) differs from standard Android approach.
		 This is due to the requirement for consinstent padding around text, while padding around drawable is specific to drawable.
		 This allows same styles to be used for buttons with/without drawables with consinstent text paddings  

		 Horizontal FastTextView paddings when no drawable:
		   paddingLeft text paddingRight

		 Horizontal FastTextView paddings when drawable is available, drawablePosition=left:
		   drawablePaddingStart drawable drawablePadding paddingLeft text paddingRight

		 Horizontal FastTextView paddings when drawable is available, drawablePosition=right:
		   paddingLeft text paddingRight drawablePadding drawable drawablePaddingStart

		 Horizontal FastTextView paddings when drawable is available and drawableOnly=true:
		   drawablePaddingStart drawable drawablePadding paddingLeft paddingRight
		   
		 Same approach is used for vertical paddings (drawblePosition=top)
		 
		 Paddings with drawablePosition=forceGravity and drawableOnly=true (icon only) are standard paddingLeft/Top/Right/Bottom.
		 drawablePadding/drawablePaddingStart are ignored, as gravity make drawable to be positioned everywhere depending on gravity, thus
		 text-related drawable paddings make no sense in this mode
		 
		 NOTE: generally, some drawables, like <inset> or other drawables with padding can override view paddings completely, when set for FastText/FastButton
		 AFTER initial XML parsing (e.g. during scene animation with the new background)
		 Fast text mitigates this by forcing the initial, XML paddings when background is updated for scene 
	-->
	<declare-styleable name="FastTextView">
		<attr name="lineBackground" format="reference|color"/>
		<!-- If true, text won't be shown and drawablePosition is set to "forceGravity". Good for drawable without text, e.g. image buttons 
			 Default=false -->
		<attr name="drawableOnly" format="boolean"/>
		<!-- Max number of lines in this view. If set to 1, single line mode is activated, similar to android TextView singleLine:
			 - no any breaks are possible, even \n doesn't break text
			 - overflowing text is cut by character, not by word
		-->
		<attr name="android:maxLines"/>
		<!-- NOTE: for compability reasons, singleLine=true just forces maxLines=1 (actual maxLines attribute is then ignored)-->
		<attr name="android:singleLine"/>
		<!-- Optional drawable -->
		<attr name="android:drawable"/>
		<!-- Padding before drawable when drawable is available. Can be negative. NOTE: paddingLeft is not applied to drawable (always applied to text)-->
		<attr name="drawablePaddingStart" format="dimension"/>
		<!-- Padding between drawable and text. Basically it's added to paddingLeft when drawable exists -->
		<attr name="android:drawablePadding"/>
		<attr name="drawablePosition">
			<enum name="left" value="0"/>
			<enum name="top" value="1"/>
			<enum name="right" value="2"/>
			<!-- Drawable will be positioned according to android:gravity. This makes sense only if drawableOnly=true, for pure icons without text -->
			<enum name="forceGravity" value="-1"/>
		</attr>
		<!-- NOTE: android:drawableTint not supported by Android 5.0, thus using w:drawableTint -->
		<attr name="drawableTint" format="reference|color"/>
		<!-- Forced drawable width. Default is drawable original width -->
		<attr name="drawableWidth" format="dimension"/>
		<!-- Forced drawable height. Default is drawable original height -->
		<attr name="drawableHeight" format="dimension"/>
		
		<!-- Default is false. If true, allow this view to have zero-height if no text (text=="" or null) nor drawable is in it.
		     NOTE: minHeight is still honored -->
		<attr name="allowZeroHeight" format="boolean"/>
		
		<!-- 
		When drawable exists, paddings and backgrrounds are distributes as follows:
		  (bg starts) drawablePaddingStart <drawable> drawablePadding (line bg starts) paddingLeft <text> paddingRight (line bg ends) (bg ends)
		When no drawable, paddings are as usual:
		  (bg starts)(line bg starts) paddingLeft <text> paddingRight (line bg ends)(bg ends)
		-->
		
		<!-- Only "none" and "end" are supported ATM -->
		<attr name="android:ellipsize"/>
		<!-- Only "none" and "characters" are supported ATM -->
		<attr name="android:capitalize"/>
		<attr name="android:minWidth"/>
		<attr name="android:minHeight"/>
 		<attr name="textScale" format="float"/>
 		<attr name="android:enabled"/>
 		<!-- NOTE: not actually processed by FastTextView, but FastTextView descendants - e.g. FastButton -->
		<attr name="android:disabledAlpha"/>
		
		<attr name="android:text"/>	
		<attr name="android:gravity"/>
		<attr name="android:lineSpacingMultiplier"/>
		<attr name="android:lineSpacingExtra"/>
	</declare-styleable>
	
	<!-- Used internally -->
	<declare-styleable name="TextAppearance">
		<attr name="android:textColor" />
		<attr name="android:textSize" />
		<attr name="android:textStyle" />
		<attr name="android:typeface" />
		<attr name="android:fontFamily" />
		<attr name="android:textAllCaps"/>
	</declare-styleable>
	

	<!-- Scene-overridable extra FastTextView params -->
	<declare-styleable name="FastTextViewSceneParams">
		<attr name="lineBackground"/>
		<attr name="android:textColor" />
		<attr name="android:maxLines"/>
		<attr name="android:background"/>
		<attr name="drawableTint"/>
		<!-- NOTE: limited support for drawable transitions. For new drawable to appear, default scene should have some default drawable set
			 Basically, that means we can transition between drawables, but we can't transition between no-drawable and drawable and vice-versa -->
		<attr name="android:drawable"/>
	</declare-styleable>
	
	
	<!-- FastButton is derived from FastTextView -->
	<declare-styleable name="FastButton">
		<!-- Default=false. If false, ripple animation is cancelled, good for cases when button click causes immediate animation/scene transition, and animated
			 ripple is not visible anyway, but causes performance drop on some devices -->
		<attr name="animOnClick" format="boolean"/>
		<attr name="disableClickHandler" format="boolean"/>
	</declare-styleable>
	
	
	<!-- com.maxmpz.widget.EditText extension -->
	<declare-styleable name="EditText">
		<attr name="drawableWidth"/>
		<attr name="drawableHeight"/>
	</declare-styleable>
	
	
	<!-- FastCheckBoxOnly is simplified check box, which is View-based (not TextView based, as standard Android checkbox), thus is much-much faster to layout and render
		 in cases when no text is needed (as list items are)
	-->
	<declare-styleable name="FastCheckBoxOnly">
		<attr name="android:drawable"/>
		<attr name="drawableTint"/>
		<attr name="android:checked"/>
	</declare-styleable>
	
	
	<!-- FastCheckBox is check box with text, based on FastTextView, thus, is faster to layout and render and supports all the FastText additional properties.
		 NOTE: android:button attribute is the same as FastTextView android:drawable, and android:buttonTint is the same as FastTextView drawableTint 
	 -->
	<declare-styleable name="FastCheckBox">
		<!-- <attr name="android:button"/> -->
		<!-- <attr name="android:buttonTint"/> -->
		<attr name="android:checked"/>
	</declare-styleable>
	
	
	<!-- FastLayout (and variants, like SceneFastLayout) is strictly one-pass, one-measure per pass (thus, fast), supporting multiple
		 layout paradigms within single layout, allowing major child layout manipulation with styles, without editing actual layout xmls
		 
		 FastLayout can replace:
		 - FrameLayout (not slower than FrameLayout, or faster, as FastLayout never remeassures children for MATCH_PARENT)
		 - LinearLayout (can be implemented via layout_flex* or via layout_consumeSpace)
		 - RelativeLayout
		 - partially ConstraintLayout 
		 - or combination of those in one layout
		 
		 FastLayout is focused on performance and thus has limitations due to strict "no-remeasure" approach:
		 - views are layed-out in xml order
		 - unless some view is referenced by other view, which triggers immediate laying out of such referenced view
		 - this may cause cycles, which are invalid and will throw StackOverflowException
		 
		 FastLayoutLP are attribures for FastLayout child views. FastLayout itself has no extra attribures
	--> 
	<declare-styleable name="FastLayoutLP">
		<!-- Gravity is applied if no attaching points are defined for the child at given axis 
			 NOTE: FastLayout takes own paddings into account when applying child layout gravity. This is different, from e.g. RelativeLayout 
			 layout_centerInParent/centerHorizontal/centerVertical, which doens't account for the layout own paddings.
		-->
		<attr name="android:layout_gravity" />
		
		<!-- NOTE: layout_*Percent works properly for FastLayout with fixed width/height (i.e. non WRAP_CONTENT) -->
		<attr name="layout_widthPercent" format="fraction"/>
		<!-- NOTE: layout_*Percent works properly for FastLayout with fixed width/height (i.e. non WRAP_CONTENT) -->
		<attr name="layout_heightPercent" format="fraction"/>
		
		<!-- Defines max possible width for the child -->
		<attr name="layout_maxWidth" format="dimension"/>
		<!-- Defines max possible height for the child -->
		<attr name="layout_maxHeight" format="dimension"/>
		
		<!-- If set, one view dimension will be matched against another, basically making view square. This works only if the source dimension has defined value, 
			 e.g. fixed dp value, MATCH_PARENT, attachLeft + attachRight, etc.
			 If source dimension is WRAP_CONTENT, layout_matchDimension is ignored.
			 NOTE: appropriate view paddings are added to final view dimensions: padding top/bottom for heightToWidth and padding left/right for widthToHeight -->
		<attr name="layout_matchDimension" format="integer">
			<!-- If set, width dimension will be forced to height, other width attributes are ignored -->
			<enum name="widthToHeight" value="0x100000"/>
			<!-- If set, height dimension will be force to width, other height attributes are ignores --> 
			<enum name="heightToWidth" value="0x200000"/>
		</attr>
		
		<!-- 
			Flex axis views are layed out and expanded (if layout_flexWeight is specified) along the vertical or horizontal axis
			
			NOTE: flex layout views are measured/layed out _before_ any other "normal" children. Thus, if FastLayout width/height is set to WRAP_CONTENT,
			intermediate FastLayout width/height is used for gravity (e.g. gravity=center or gravity=right/bottom), not the final dimensions

			NOTE: any other w:layout_* properties are ignored for "flex" views 
		-->
		<attr name="layout_flexAxis">
			<enum name="horizontal" value="0x0400"/><!-- NOTE: should match FastLayoutParams.FLAG_FLEX_* -->
			<enum name="vertical" value="0x0800"/>
		</attr>
		
		<!-- 
			NOTE: FastLayout uses weightSum=num of flexWeight children
			Basically this means, layout_flexWeight=1 children always expands uniformely.
			Also, if no layout_flexWeight attribute is specified for a view, it's never stretched/shrinked, just stays as layout_width/height commands. 
		--> 
		<attr name="layout_flexWeight" format="float"/>
		
		<!-- If true, this and all next flex views are layed out bottom-top in xml order -->
		<attr name="layout_flexReverse" format="boolean"/>
		
		<!-- layout_attach* attribute can attach view to:
			 - any other child view, including flex layout child.
			   Cyclic references are not allowed (you'll see stack overflow exception). The referenced view will be layed out first (xml order is ignored).
			 - "parent" attaches to parent side, accounting for any "consumed" space (if any) from side(s) where view is attached or "gravitated" to 
			 - percent value (e.g. 50%) positions view by offset calculated form parent width/height * percent.
			   This works only if width/height is fixed on the FastLayout (i.e. not WRAP_CONTENT).
			 - "none" - resets any previous value (e.g. set by parent style)
		-->
	 	<!-- layout_attachLeft => attaches left edge of view to right edge of target view or to parent left, or to parent fraction width from left -->
		<attr name="layout_attachLeft" format="reference|integer|fraction">
			<enum name="parent" value="0"/>
			<enum name="none" value="-1"/>
			<!-- Behaves as "parent", unless parent is under Android navigation bar and supports special interface - then attaches to tje right inset == navigation bar to the right 
			    (if navigation bar is on the right). Attaching to an inset will ignore parent padding. Special interface supported by ListWidget, TopNavSceneFastLayout. 
			    Attaching to an inset makes sense for parent views taking whole screen dimension (width or height or both) or at least aligned to the appropriate screen side -->
			<enum name="inset" value="-2"/>
		</attr>
		<attr name="layout_attachTop" format="reference|integer|fraction">
			<enum name="parent" value="0"/>
			<enum name="none" value="-1"/>
			<!-- Behaves as "parent", unless parent is under status bar and supports special interface - then attaches to the top inset == status bar height.
			     Attaching to an inset will ignore parent padding. Special interface supported by ListWidget, TopNavSceneFastLayout.
			     Attaching to an inset makes sense for parent views taking whole screen dimension (width or height or both) or at least aligned to the appropriate screen side -->
			<enum name="inset" value="-2"/>
		</attr>
		<attr name="layout_attachRight" format="reference|integer|fraction">
			<enum name="parent" value="0"/>
			<enum name="none" value="-1"/>
			<!-- Behaves as "parent", unless parent is under Android navigation bar and supports special interface - then attaches to the left inset == navigation bar on the left 
			     (if navigation bar on the left). Attaching to an inset will ignore parent padding. Special interface supported by ListWidget, TopNavSceneFastLayout.
			     Attaching to an inset makes sense for parent views taking whole screen dimension (width or height or both) or at least aligned to the appropriate screen side -->
			<enum name="inset" value="-2"/>
		</attr>
		<attr name="layout_attachBottom" format="reference|integer|fraction">
			<enum name="parent" value="0"/>
			<enum name="none" value="-1"/>
			<!-- Behaves as "parent", unless parent is under Android navigation bar and supports special interface - then attaches to the bottom inset == navigation bar on the bottom 
			     (if navigation bar on the bottom). Attaching to an inset will ignore parent padding. Special interface supported by ListWidget, TopNavSceneFastLayout.
			     Attaching to an inset makes sense for parent views taking whole screen dimension (width or height or both) or at least aligned to the appropriate screen side -->
			<enum name="inset" value="-2"/>
		</attr>
		
		<!-- layout_attachRightToRight => attaches right edge of view to right edge of target view. No fraction or parent here, 
			 as layout_attachRightToRight="fraction %" would be the same as layout_attachRight="fraction %",
			 and layout_attachRightToRight="parent" would be the same as layout_attachRight="parent".
			 layout_attachRightToRight and layout_attachRight are mutually exclusive. The last parsed attribute is in effect.
			 Cyclic references are not allowed (you'll see stack overflow exception). The referenced view will be layed out first (xml order is ignored).
		-->
		 
		<attr name="layout_attachRightToRight" format="reference"/>
		<attr name="layout_attachBottomToBottom" format="reference"/>
		<attr name="layout_attachLeftToLeft" format="reference"/>
		<attr name="layout_attachTopToTop" format="reference"/>
		
		<!-- By default, view gravitates to its parent (via standard android:layout_gravity). If layout_gravityTarget is some non-parent view id, 
			 that view becomes the point of gravitaion. E.g. if android:gravity="center" and layout_gravityTarget="@id/some_view", this view
			 will be centered relatively to "some_view".
			 If gravity target view doesn't exist, or is GONE, view gravitates to parent.
			 Cyclic references are not allowed (you'll see stack overflow exception). The referenced view will be layed out first (xml order is ignored).
			 Not supported for layout_flex views
			 NOTE: this disables accounting for gravity based consumed parent space, as gravityTarget view bounds become the reference bounds for this view
			 Consume space still works if layout_attach*="parent" is used
		-->
		<attr name="layout_gravityTarget" format="reference|integer">
			<enum name="parent" value="0"/>
		</attr>
		
		
		<!-- layout_consumeSpace "consumes" space within parent from one or two sides, or both (layout_consumeSpace="both").
			 If parent space is consumed, any subsequent child will be layed out with offset. Gravity is also affected.
			 There are 4 sides in parent view which can be consumed - left, top, right, bottom.
			 
			 Views aligned to left (or left and right), consume left space, view aligned to top - top space, views aligned
			 to right - right space, and aligned to bottom - bottom space.
			 The alignment here means either layout_gravity (per appropiate axis), or layout_attach* attribute, if layout_gravity is missing for given axis.
			 
			 layout_consumeSpace=reset_* resets such layout consumption (works similar to new line in textor <br/> in html).
			 By default, only the side, which view is aligned to is reset. 
			 Special reset_full_* values can reset both sides.
			 
			 For example: 2 columns 50%|50% height=200dp, then 2 rows (width=100%) height=100dp
			 	<view w:layout_widthRelative="50%" android:layout_height="200dp" w:layout_consumeSpace="horizontal"/>
			 	<view w:layout_widthRelative="50%" android:layout_height="200dp" w:layout_consumeSpace="vertical|reset_horizontal"/> 
			 	
			 	<view android:layout_width="match_parent" android:layout_height="100dp" w:layout_consumeSpace="vertical"/>
			 	<view android:layout_width="match_parent" android:layout_height="100dp" w:layout_consumeSpace="vertical"/>
			 
			 
		-->
		<attr name="layout_consumeSpace">
			<flag name="none" value="0"/>
			<flag name="horizontal" value="0x1000000"/><!-- NOTE: should match FastLayoutParams.FLAG_CONSUME_* -->
			<flag name="vertical" value="0x2000000"/>
			<flag name="both" value="0x3000000"/>
			<!-- Resets appropriate horizontal consumed space on one side (depending on view gravity, e.g. view attached to left will reset left side consumed space) -->
			<!-- Works like <br/> -->
			<flag name="reset_horizontal" value="0x4000000"/>
			<!-- Resets appropriate vertical consumed space on one side (depending on view gravity, e.g. view attached to top will reset top side consumed space) -->
			<flag name="reset_vertical" value="0x8000000"/>
			<!-- reset_horizontal and reset_vertical combined -->
			<flag name="reset_both" value="0xC000000"/>
	
			<!-- Resets horizontal consumed space on both sides (left/right) -->
			<flag name="reset_full_horizontal" value="0x10000000"/>
			<!-- Resets horizontal consumed space on both sides (top/bottom) -->
			<flag name="reset_full_vertical" value="0x20000000"/>
			
			<!-- Resets horizontal consumed space on all 4 sides (left/right/top/bottom) -->
			<flag name="reset_full" value="0x30000000"/>
			
			<!-- Automatically resets appropriate axis as soon as no more space on this axis exists and consumes other axis on such reset.
				 This results in automatic layout break to new "line" (or column, for vertical layout).
				 E.g. if multiple views have layout_consumeSpace="horizontal|reset_auto", they will be layed out in rows.
				 NOTE: layout_consumeSpace is processed after given view is layed out. Thus, if there is no enough space for view due to consumed space,
				 view will "overshoot" or will be shrinked. Thus, reset_auto works best with predefined percent view dimensions, e.g.
				 multiple views with w:layout_widthPercent="25%" w:layout_consumeSpace="horizontal|reset_auto" will be layed out
				 in rows, 4 view per row
				 NOTE: reset_auto by default resets horizontal axis and consumes vertical.
				 Only if vertical (without also horizontal) is specified for given view, vertical axis will be reset, and horizontal consumed.
				 Other reset_* flags are processed as usual, thus, can cause double consuption and other side effects, if used together with reset_auto
			 -->
			<flag name="reset_auto" value="0x40000000"/>
		</attr>
		
		<!-- android:layout_gravity will be used if layout_forceGravityIfGone="@id/some_view_id" view is missing or GONE --> 
		<attr name="layout_forceGravityIfGone" format="reference"/>
		
		<!-- if any of layout_attach* target ids are "gone", view is attached to appropriate parent side.
			 NOTE: view is attached to parent side if no such target "attach to" view exists, even without this property set to true.
			 layout_consumeSpace attribute is still processed -->
		<attr name="layout_attachToParrentIfGone" format="boolean"/>
		
		<!-- View margins are compensated for given scale (thus, margins are not affected by scaleX/scaleY/scale transformations)
			 Requires pivot set to 0, 0 (i.e. android:transformPivotX=0, android:transformPivotY=0). Doesn't work with MATCH_PARENT,
			 though works with attachLeft/attachRight combintation -->
		<attr name="layout_compensateScale" format="float"/>
		
		<!-- If true, view will be given UNSPECIFIED measure spec when view size is wrap_content on given axis.
			 By default, this is disabled, thus views measure requested size limited by this container size. 
			 layout_unlimitedMeasure="true" may be required for cases when there is only one child view which should grow beyond this container size
			 on the scrollable axis. Such behavior is close to Android ScrollableView children
		-->
		<attr name="layout_unlimitedMeasure" format="boolean"/>

		<!-- NOTE: basic MarginLayoutParams attrs are needed for programmatic LP creation based on style attr/res. MarginLayoutParams doesn't support that,
			 so FastLayoutLP handles margin parsing on its own
			 NOTE: there is a slight difference for marginStart/End parsing. FastLayout always parses them in supportsRtl=true mode, meaning,
			 if marginStart or marginEnd or both are defined, then marginStart and marginStart are used instead of marginLeft/Right.
			 If only one of the marginStart/End attributes defined, other attribute is considered to be 0 (marginLeft/Right ignored) 
		-->
		
		<attr name="android:layout_width"/>
		<attr name="android:layout_height"/>
		<attr name="android:layout_margin"/>
		<attr name="android:layout_marginLeft"/>
		<attr name="android:layout_marginTop"/>
		<attr name="android:layout_marginBottom"/>
		<attr name="android:layout_marginRight"/>
		<attr name="android:layout_marginStart"/>
		<attr name="android:layout_marginEnd"/>
	</declare-styleable>
	
	<!-- Constant definitions for FastLayoutLP layout_matchDimension. Can be used e.g. via resource specific @integer --> 
	<integer name="layout_matchDimension_widthToHeight" tools:ignore="UnusedResources">0x100000</integer>
	<integer name="layout_matchDimension_heightToWidth" tools:ignore="UnusedResources">0x200000</integer>

	<!-- Generic Scene extra attributes, usually applied to layouts starting with Scene* (e.g. SceneFastLayout) -->
	<declare-styleable name="Scene">
		<!-- Default false. If true, scene allows scene-wide state anims, otherwise only specific per-view StateAnims are possible -->
		<attr name="enableStateAnim" format="boolean"/>
		<attr name="clipChildrenForSceneAnim" format="boolean"/><!-- Default false. NOTE: not used ATM -->
		<!-- Default false. If private, child views are not processed by scenes, initiated outside of this view -->
		<attr name="privateScene" format="boolean"/>
	</declare-styleable>
	
	<!-- Extra scene parameters supported for FastLayout children -->
	<declare-styleable name="SceneFastLayoutViewSceneParams">
		<!-- If true, per view params will be applied for this scene -->
		<attr name="applyViewParams"/>
		<attr name="android:background"/>
		<attr name="android:elevation"/>
	</declare-styleable>

		
	<!-- Scroller for main Poweramp list with 2 modes - az chars or standard draggable thumb. PowerList switches modes depending on data it's showing --> 
	<declare-styleable name="ListScrollerView">
		<!-- Drawable for thumb. Can have enter/exit animation -->
		<attr name="android:thumb"/>
		<!-- Track drawable. Enter/exit animation is ignored. Instead, StateAnim is applied -->
		<attr name="android:track"/>
		
		<!-- Like standard android transformPivotX/Y, but expressed as percent -->
		<attr name="transformPivotX_percent" format="fraction"/>
		<attr name="transformPivotY_percent" format="fraction"/>
		
		<!-- Background to use in az scrolling mode -->
		<attr name="azBackground" format="reference|color"/>
		<!-- Touched background to use in az scrolling mode -->
		<attr name="azTouchedBackground" format="reference|color"/>
		<!-- Text scale to use in az scrolling mode -->
		<attr name="azTextScale" format="float"/>
		<!-- If exists, scroll up small drawable will be drawn on top of az -->
		<attr name="azScrollUp" format="reference"/>		
				
		<!-- The characters to use in az scrolling mode. Should be properly sorted -->
		<attr name="azChars" format="string"/><!-- NOTE: also should be defined for main theme, as Pages take it from there -->
		
		<!-- Padding for az scrolling mode -->		
		<attr name="azPaddingLeft" format="dimension"/>
		<!-- Padding for az scrolling mode -->
		<attr name="azPaddingRight" format="dimension"/>
		<!-- Padding for az scrolling mode -->
		<attr name="azPaddingTop" format="dimension"/><!-- NOTE: is azSize is used (valid not @null/@empty value, > 0), then azPaddingTop/azPaddingBottom are ignored, AZ centered -->
		<!-- Padding for az scrolling mode -->
		<attr name="azPaddingBottom" format="dimension"/>

		<!-- Optional size (height) for az scrolling mode. Can be a percentage of available height or direct fixed size -->
		<attr name="azSize" format="dimension|fraction"/>
		
		<!-- Also, android:text* attributes are supported -->
		<!-- NOTE: font size is automatically selected depending on space available in the cells -->
	</declare-styleable>
	
	<!-- Poping out character shown when user actively scrolls in az mode -->
	<declare-styleable name="ListIndexerPopupView">
		<attr name="indexerPopupMode">
			<enum name="fixed" value="0"/><!-- Popup stays as specified by layout --> 
			<enum name="moveWithThumb" value="1"/><!-- Popup translationY is modified to match scrolling thumb. Appropriate layout should be given in xml (e.g. popup should be on top, aligned right to scrollbar -->
		</attr>
		<!-- Additional margin to apply in moveWithThumb + moving thumb mode. NOTE: applied as translationX -->
		<attr name="thumbModeOffsetX" format="dimension"/>
	</declare-styleable>
	
	<!-- Used internally -->
	<declare-styleable name="BgTransSceneParams">
		<attr name="android:background"/>
	</declare-styleable>
		
	<!-- Expandable Navbar area -->			
	<declare-styleable name="NavbarExtension">
		<attr name="shim" format="reference"/><!-- id of shim view which covers whole screen when NavbarExtension is expanded -->
		<attr name="content" format="reference"/><!-- id of the content layout. If null/not specified - navbar_extension is the content view itself -->
		<attr name="twoLineEnterAnimTime" format="integer"/><!-- Miniplayer enter time -->
		<attr name="twoLineExitAnimTime" format="integer"/><!-- Miniplayer exit  time -->
	</declare-styleable>
	
	<!-- Special top-level layout for poping-out menus. Poping out views are transformed into menu and attached to this layout for a popup duration --> 
	<declare-styleable name="PopupMenuHelper">
		<!--
			Color used to shade contents of the list when some popup menu is shown.
			Used for both color and blue shade types. 
			For color - it's just a color. 
			For blur - it's additional color which is also applied before blur. 
		-->
		<attr name="shadeColor" format="color|reference"/>
		
		<!-- <attr name="shadeType"/> -->
		<!-- <attr name="shadeBlurSubsample"/> --><!-- Subsample scale to improve performance. 0.1 recommended -->
		<!-- <attr name="shadeBlurRadius"/> --><!-- Blur radius -->
		<!-- Defines popup overscan area, e.g. set this when popup menu placeholder layout is placed under status bar (overscan=top), 
			 android navigation bar (overscan=bottom) or both (overscan=top|bottom). 
			 This is used for additional vertical alignment accounting for overscans 
		-->
		<!-- Sync with PopupMenuHelper.java -->
		<!-- NOTE: not used ATM
		<attr name="overscan">
			<flag name="none" value="0"/>
			<flag name="top" value="0x1"/>
			<flag name="bottom" value="0x2"/>
		</attr>
		-->
	</declare-styleable>
	
	<!-- Used internally in dialogs. Behavior - pseudo-view-tag which attaches to some real view and modifies its behavior in some way -->
	<declare-styleable name="RootSceneActivityBehavior">
		<attr name="windowIsResizable" format="boolean"/>
	</declare-styleable>
	
	<!-- Used internally in dialogs. Behavior - pseudo-view-tag which attaches to some real view and modifies its behavior in some way -->
	<declare-styleable name="AdjustToSoftKeyboardBehavior">
		<attr name="android:enabled"/>
	</declare-styleable>

	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) 
	     which is able to load specific layout for one or multiple scenes, and unload it later, if needed.
	     Similar to Android Stub view, but is not a view (not visible, doesn't participate in layout/rendering/etc.) -->		
	<declare-styleable name="LoadableBehavior">
		<!-- Defines this loadable behavior id. Used by code to find given behavior --> 
		<attr name="android:id"/>
		<!-- Target layout to inject -->
		<attr name="android:layout"/>
		<!-- Target scene id layout will load for. This is usually not needed and missing, as code decides when to load this behavior instead -->
		<attr name="loadForScene" format="reference"/>
		<attr name="loadForScene_2" format="reference"/>
		<attr name="loadForScene_3" format="reference"/>
		<attr name="loadForScene_4" format="reference"/>
		<attr name="loadForScene_5" format="reference"/>
		<attr name="loadForScene_6" format="reference"/>
		<attr name="loadForScene_7" format="reference"/>
		<!-- Optional insert position. Default is end (views appended to parent, fastest) -->
		<attr name="insertAt" format="integer">
			<!-- Insert at position of behavior. 
				 NOTE: position is recorded when behavior is first parsed, thus, subsequent changes to view hierarchy can move this insert point 
			-->
			<enum name="thisPosition" value="-2"/><!-- Sync with LoadableBehavior -->
			<!-- Add to the end of parent view (default) -->
			<enum name="end" value="-1"/>
			<!-- Insert as first child in the parent view -->
			<enum name="start" value="0"/>
		</attr>
		<!-- Default is "onSceneEnd". NOTE: LoadableBehaviors can be loaded/unloaded directly by code.
			 unload="never" makes LoadableBehavior similar to StubView, but it's not a view and controlled by scenes (or code).
		 -->
		<attr name="unload">
			<!-- Unloads when scene moves away from behavior defined loadForScene* sceneId -->
			<enum name="onSceneEnd" value="0"/><!-- Sync with LoadableBehavior -->
			<!-- Never automatically unloaded (but can be unloaded by code -->
			<enum name="never" value="1"/><!-- Sync with LoadableBehavior -->
		</attr>		
	</declare-styleable>
	
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which enables sending commands to Poweramp event buses
		 NOTE: also applied to BusActionButton -->
	<declare-styleable name="BusActionBehavior">
		<attr name="busId" format="reference"/><!-- E.g. @id/list (== bus supporting view id) or @id/bus_gui -->
		<attr name="msgId" format="reference"/><!-- E.g. @id/cmd_list_select_all -->
		<attr name="longPressMsgId" format="reference"/><!-- E.g. @id/cmd_list_select_all -->
		
		<attr name="repeatLongPressPeriod" format="integer"/><!-- If non zero, repeated events sent each repeatLongPressPeriod ms -->
		
		<attr name="arg1" format="reference|integer|boolean|float|fraction|dimension|color"><!-- Optional argument #1 -->
			<enum name="checkedState" value="-1"/><!-- If parent view is Chechable, then arg will have checked state (1==checked)) -->
		</attr>
		<attr name="arg2" format="reference|integer|boolean|float|fraction|dimension|color"><!-- Optional argument #2 -->
			<enum name="checkedState" value="-1"/>
		</attr>
		<!-- Optional string argument -->
		<attr name="string" format="string"/>
		
		<!-- Optional confirmation dialog title. Should be set for dialog to show -->
		<attr name="confirmTitle" format="string|reference"/>
		<!-- Optional confirmation dialog text -->
		<attr name="confirmText" format="string|reference"/>
		
		<!-- Delay for sending message in ms -->
		<attr name="clickDelay" format="integer"/>
		
		<attr name="disableForStateBusId" format="reference"/><!-- See BusDisabledForStateBehavior -->
	</declare-styleable>
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) to enable/disable views based on Poweramp state buses
		 NOTE: also applied to BusActionButton -->
	<declare-styleable name="BusDisabledForStateBehavior">
		<attr name="disableForStateBusId"/><!-- E.g. @id/list -->
		<attr name="disableForStateId" format="reference"/><!-- E.g. @id/state_list_selection_mode -->
		<attr name="disableForStateId_2" format="reference"/><!-- Valid only if stateId defined -->
		<!-- <attr name="stateId_3" format="reference"/> --><!-- Valid only if stateId defined -->
		<!-- <attr name="stateId_4" format="reference"/> --><!-- Valid only if stateId defined -->
		<attr name="disableForStateMsgId" format="reference"/><!-- Can match stateIds or can be any other message -->
		<attr name="disableForStateMsgId_2" format="reference"/><!-- Can match stateIds or can be any other message -->
	</declare-styleable>
	
	<!-- Number of attributes to show formatted text based on Poweramp state buses -->
	<declare-styleable name="BusStateFormatValue">
		<attr name="android:id"/>
		<attr name="busId"/><!-- E.g. @id/list -->
		<attr name="stateId" format="reference"/><!-- E.g. @id/state_list_selection_count -->
		<attr name="secondaryStateId" format="reference"/><!-- E.g. @id/state_list_selectable_item_count -->
		<!-- String like "Count: %d" or array with multiple values. Array also works with boolean-like values (index=0 - false value, index=1 - true value) -->
		<attr name="format" format="string|reference"/> 
		<attr name="type"><!-- Type of state to format -->
			<enum name="integer" value="0"/>
			<enum name="string" value="1"/>
		</attr>
	</declare-styleable>
	
	<!-- SelectablePopupButtonLayout attributes which define list selection workflow -->  
	<declare-styleable name="BusSelectablePopupButtonLayout">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId" format="reference"/>
		<!-- State id to set buttons to -->
		<attr name="stateId"/>
		<!-- Message id to listen from state bus msgbus and set buttons to --> 
		<attr name="msgId"/>
		
		<!-- If set, arg1 will be overriden for BusActionButtons inside when clicked NOT in popup mode -->
		<attr name="arg1"/>
		<!-- If set, arg2 will be overriden for BusActionButtons inside when clicked NOT in popup mode -->
		<attr name="arg2"/>
		<!-- If set, string will be overriden for BusActionButtons inside when clicked NOT in popup mode -->
		<attr name="string"/>
		
		<!-- Buttons message @id - the same command message id is used for all buttons -->
		<attr name="buttonsMsgId" format="reference"/>
		<!-- Buttons bus id - the same msg bus is used for all buttons -->
		<attr name="buttonsBusId" format="reference"/>
		<!-- Integer-array of arg1 for each button -->
		<attr name="buttonsArg1" format="reference"/>
	</declare-styleable>
		
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which selectes child view based on Poweramp state/msg bus -->
	<declare-styleable name="BusSelectableBehavior">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		<!-- State id to set buttons to -->
		<attr name="stateId"/>
		<!-- Message id to listen from state bus msgbus and set buttons to. arg1 is checked for state. arg1 == -1 is ignored (no changes to buttons) --> 
		<attr name="msgId"/>
	</declare-styleable>
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which enables left-right swiping scrolling on a layout.
	     See also AAScrollingBehavior --> 
	<declare-styleable name="BusAAScrollingBehavior">
		<!-- Time to scroll between 2 pages when tab/nav button pressed -->
		<attr name="posScrollAnimTime" format="integer"/><!-- ms -->
		<!-- Time to settle to page when scrolled manually -->
		<attr name="settleAnimTime" format="integer"/><!-- ms -->
		
		<attr name="maxOvershoot"/>
		
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		<!-- State id to set buttons to -->
		<attr name="stateId"/>
		<!-- Message id to listen from state bus msgbus and set buttons to --> 
		<attr name="msgId"/>
		
		<attr name="android:colorEdgeEffect"/><!-- Defines overshoot edge effect color -->
	</declare-styleable>
	
	<!-- Extra attributes for BusStateEnabledBehavior or BusStateActionButton, which manipulate view enabled state based on state -->
	<declare-styleable name="BusStateEnabled">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		
		<!-- State to retrieve from StateBus -->
		<attr name="stateId" format="reference"/>
		
		<!-- Msg id to listen for state change. If not specified, stateId is used -->
		<attr name="stateMsgId"/>
		
		<attr name="enableByState"><!-- Sync with BusStateEnabledHelper.java -->
			<!-- View is enabled when stateId is boolean and true -->
			<enum name="matchBoolean" value="0"/>
			<!-- View is enabled when stateId is boolean and false -->
			<enum name="dontMatchBoolean" value="1"/>
			<!-- View is enabled when stateId is integer and matches matchArg -->
			<enum name="matchInteger" value="2"/>
			<!-- View is enabled when stateId is integer and doesn't match matchArg -->
			<enum name="dontMatchInteger" value="3"/>
		</attr>
		
		<!-- Used to set matching value for stateEnabledLogic=matchInteger/dontMatchInteger -->
		<attr name="stateMatchArg" format="reference|integer"/>
	</declare-styleable>
		
	<!-- Extra options for BusCheckableStateBehavior, BusCheckableStateHelper, BusCheckBox which allow checking/unchecking view based on state -->  
	<declare-styleable name="BusCheckableStateHelper">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		<!-- Boolean state to retrieve from StateBus. May match stateMsgId -->
		<attr name="booleanStateId" format="reference"/>
		<!-- Msg id with the boolean value in arg1 to listen to -->
		<attr name="stateMsgId" format="reference"/>
		<!-- If true, true state == checked, otherwise, false state == checked -->
		<attr name="checkedIfTrue" format="boolean"/>
		<!-- Cmd to issue on check -->
		<attr name="checkCmdId" format="reference"/>
		<!-- Cmd to issue on uncheck -->
		<attr name="uncheckCmdId" format="reference"/>
	</declare-styleable>
	
	<!-- Extra options for BusStatusText which update text based on bus msg/state -->
	<declare-styleable name="BusText">
		<!-- State bus to listen/query to -->
		<attr name="stateBusId"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_2" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_3" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_4" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_5" format="reference"/>
		<!-- Msg id to listen to -->
		<attr name="updateMsgId_6" format="reference"/>
		<!-- String state for label to display  -->
		<attr name="labelStateId" format="reference"/>
		<!-- Optional format string like "Preset: %s" or array with multiple values. Array also works with boolean-like values (index=0 - false value, index=1 - true value) -->
		<attr name="labelFormat" format="string"/>
		<!-- Int state for icon to display  -->
		<attr name="iconStateId" format="reference"/>
		<!-- Optional scene in which no updates happen. This view should have SceneParams for such scene -->
		<attr name="noUpdateInScene" format="reference"/>
		<!-- Show the default (android:text) text if state is empty/null -->
		<attr name="defaultTextOnNoState" format="boolean"/>
	</declare-styleable>
	
	<!-- FastButton which is able to start specified Activity -->
	<declare-styleable name="IntentActionButton">
		<attr name="android:action"/>
		<attr name="android:targetClass"/>
		<attr name="android:targetPackage"/>
		<attr name="string"/><!-- EXTRA_OBJ -->
	</declare-styleable>
		
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) used to implement Poweramp dialogs in a separate activity 
		 NOTE: dialog behavior always have implicit id=@id/behavior_dialog -->
	<declare-styleable name="DialogBehavior">
		<attr name="dialogAltOutScene"/><!-- REVISIT: this is read from Theme, not from behavior styles/attributes -->
	</declare-styleable>
		
	
	<!-- List item view - heading with small button --> 
	<declare-styleable name="SeparatorItemView">
		<!-- Extra padding (can be negative) to apply when this is the first item in list -->
		<attr name="paddingTopWhenFirst" format="dimension"/>
	</declare-styleable>
	
	<!-- Empty/invisible view which changes its size depending on params below. Used as anchor for other views -->
	<declare-styleable name="SmartSpacer">
		<!-- Some view within this view parent, which will be queried for existance and visibility=GONE. When view is missing/GONE, heightWhenMissing is forced
			 for this view, otherwise, default height is applied -->
		<attr name="heightTargetId" format="reference"/>
		<!-- The height this view has when heightTargetId is missing/GONE -->
		<attr name="heightWhenMissing" format="dimension"/>
				
		<!-- Some view within this view parent, which will be queried for existance and visibility=GONE. When view is missing/GONE, widthtWhenMissing is forced
			 for this view, otherwise, default width is applied -->
		<attr name="widthTargetId" format="reference"/>
		<!-- The width this view has when widthTargetId is missing/GONE -->
		<attr name="widthWhenMissing" format="dimension"/>
	</declare-styleable>
	
	<!-- Behavior, which is currently integrated into com.maxmpz.widget.player.TopNavSceneFastLayout (=> @style/TopContainer) 
	     Defines and controls all the top-level navigation -->
	<declare-styleable name="TopNavBehavior">
		<!-- Main screen enter animation duration. Applied to UI, but not inside List. List has own animation durations -->
		<attr name="animMainEnterTime" format="integer"/>
		<!-- Main screen exit animation duration. Applied to UI, but not inside List. List has own animation durations -->
		<attr name="animMainExitTime" format="integer"/>
		<!-- Play <-> pause animation duration -->		
		<attr name="playStateAnimTime" format="integer"/>
		<!-- Other screes animation durations. Applied to UI, but not inside List. List has own animation durations -->
		<attr name="animTime"/>
		<!-- State anim duration, e.g. for state_seeking anim -->
		<attr name="stateAnimTime" format="integer"/>
		<!-- Vis enter/exit anim duration -->
		<attr name="visAnimTime" format="integer"/>
		<!-- Temporary UI (on touch, when vis is enabled) duration -->
		<attr name="tempUITime" format="integer"/>
		
		<!-- 
			 AA background hide anim duration during navigation 
			 NOTE: this duration works for main => eq navigation. 
			 Main => lib and main => search navigation are different, as navigation is withing the list itself.
			 List has own animation durations
		-->
		<attr name="aaBlurExitAnimTime" format="integer"/>
		<!-- Vis entering anim duration during navigation -->
		<attr name="visEnterAnimTime" format="integer"/>
		<!-- Vis exiting anim duration during navigation -->
		<attr name="visExitAnimTime" format="integer"/>
		<!-- AA entering anim duration during navigation -->
		<attr name="aaEnterAnimTime" format="integer"/>
		
		<!-- Fast time to change AA blur e.g. when new bitmap is loaded. Should be fast
			 NOTE: transition time between different bitmaps blurs generally is defined by actual AA animation time, which depends on many things,
			 or can be e.g. manual, thus controlled by user
		-->
		<attr name="aaBlurUpdateAnimTime" format="integer"/>
		
		<!-- Anim time to use if AA blur loaded with the delay -->
		<attr name="aaBlurLongerUpdateAnimTime" format="integer"/>
		
	</declare-styleable>
	
	<!-- Base attributes for poping-out layout, transforming into menu on click/long click -->
	<declare-styleable name="PopupLayout">
		<!-- Default is false, and popup is opened by long click. If true, popup is opened by short click -->
		<attr name="openOnClick" format="boolean"/>
		<!-- Default is true. If true, opening popup temporarily hides other popups/top panels/etc. -->
		<attr name="modal" format="boolean"/>
		<!-- If true, inner scrolling will be activated for popup -->
		<attr name="innerScrolling" format="boolean"/>

		<attr name="popupEnterAnimTime"/><!-- ms -->
		<attr name="popupExitAnimTime"/><!-- ms -->
		<attr name="menuPlaceholder"/>
		
		<!-- Layout to inflate into popup -->
		<attr name="menuItemsLayout" format="reference"/>
		<attr name="closeOnClickInside" format="boolean"/>
		
		<!-- True by default. Disables layout passes in parent scene while in popup mode. This is to avoid jumping views around this view, as the view is detached
		     completely from current parent while in popup mode. Alternatively use private scene layout, or set this to false and not rely on this view layout --> 
		<attr name="disableParentLayoutForPopup" format="boolean"/>
	</declare-styleable>
	
	<!-- Layout looking like button, but transformed to a menu on click/long click -->
	<declare-styleable name="PopupButtonLayout">
		<!-- Default is false, and popup is opened by long click. If true, popup is opened by short click -->
		<attr name="openOnClick"/> 
		<attr name="modal"/>
		<attr name="popupEnterAnimTime"/><!-- ms -->
		<attr name="popupExitAnimTime"/><!-- ms -->
		<attr name="buttonAnimTime" format="integer"/><!-- ms -->
		<attr name="menuPlaceholder"/>
		<attr name="menuItemsLayout"/>
		
		<!-- Button labels string @array --> 
		<attr name="buttonsLabels" format="reference"/>
		<!-- Button drawables @array -->
		<attr name="buttonsDrawables" format="reference"/>
		
		<!-- Button style (e.g. PopupButton) -->
		<attr name="buttonStyle" format="reference"/>
		<!-- Button style (e.g. PopupButton_scene_button_menu) -->
		<attr name="menuButtonStyle" format="reference"/>
		
		<!-- Default is true -->
		<attr name="closeOnClickInside"/>
		
		<!-- True by default. Disables layout passes in parent scene while in popup mode. This is to avoid jumping views around this view, as the view is detached
		     completely from current parent while in popup mode. Alternatively use private scene layout, or set this to false and not rely on this view layout --> 
		<attr name="disableParentLayoutForPopup"/>
		
		<attr name="toastOnPress" format="reference"/>
	</declare-styleable>
	
	
	<!-- Layout for toasts -->
	<declare-styleable name="ToastFrameLayout">
		<attr name="toastDuration" format="integer"/><!-- ms. This is default value, which is often overriden by code -->
	</declare-styleable>
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which enables scrolling in a layout.
	     Scrolling direction is defined by layout android:scrollbars -->
	<declare-styleable name="ScrollingBehavior">
		<attr name="maxOvershoot" format="dimension"/>
		<attr name="disallowParentScroll" format="boolean"/>
		<attr name="noScrollbars" format="boolean"/><!-- If true, avoid enabling scrollbar drawing -->
		
		<attr name="android:colorEdgeEffect"/><!-- Defines overshoot edge effect color -->
	</declare-styleable>
	
	<!-- Behavior (pseudo-view-tag which attaches to some real view and modifies its behavior in some way) which enables aa-like horizontal scrolling in a layout.
	     See also BusAAScrollingBehavior -->
	<declare-styleable name="AAScrollingBehavior">
		<attr name="maxOvershoot"/>
	</declare-styleable>
	
	<!-- Poping-out button which is transformed into a PowerList -->
	<declare-styleable name="PopupListLayout">
		<!-- Default is true. If true, opening popup temporarily hides other popups/top panels/etc. -->
		<attr name="modal" format="boolean"/>

		<attr name="popupEnterAnimTime"/><!-- ms -->
		<attr name="popupExitAnimTime"/><!-- ms -->
		<attr name="menuPlaceholder"/>
		
		<!-- PowerList style for list used in popup. Default is @style/PopupListLayoutList -->
		<attr name="popupListStyle" format="reference"/>
		
		<!-- True by default. Disables layout passes in parent scene while in popup mode. This is to avoid jumping views around this view, as the view is detached
		     completely from current parent while in popup mode. Alternatively use private scene layout, or set this to false and not rely on this view layout --> 
		<attr name="disableParentLayoutForPopup"/>
		
		<!-- State bus id for label and messages to listen to -->
		<attr name="stateBusId"/>
		
		<!-- Optional long state to listen to/retrieve from StateBus to change selectedItemStateId -->
		<attr name="selectedItemStateId" format="reference"/>
		
		<!-- Msg id to listen for state change (both selected item and label) -->
		<attr name="stateMsgId" format="reference"/>
		
		<!-- String state for label to display. If not set, label text is not change/updated -->
		<attr name="labelStateId" format="reference"/>
		
		<!-- Optional format string like "Preset: %s" or array with multiple values. Array also works with boolean-like values (index=0 - false value, index=1 - true value) -->
		<attr name="labelFormat" format="string"/>
				
		<!-- Height of list row -->
		<attr name="listItemSize"/>
	</declare-styleable>

	<!-- FastLayout with an animated line background, which animates view resize -->
	<declare-styleable name="BgAnim">
		<!-- lineBackground animation duration --> 
		<attr name="lineAnimTime" format="integer"/>
		
		<!-- Line background drawable --> 
		<attr name="lineBackground"/>
		
		<!-- Default false. If private, child views are not processed by scenes, initiated outside of this view -->
		<attr name="privateScene" format="boolean"/>
	</declare-styleable>
	
	<!-- Used internally -->
	<declare-styleable name="ColorStateListItem">
		<attr name="android:color" />
		<attr name="alpha" format="float" />
		<attr name="android:alpha"/>
	</declare-styleable>
	
	<!-- Visualization panel layout -->	
	<declare-styleable name="VisPanelFrame">
		<!-- Size of normal item -->
		<attr name="itemSize" format="dimension"/>
		<!-- Size of list item -->
		<attr name="listItemSize" format="dimension"/>
	</declare-styleable>
		
	<!-- Additional attributes for selection menu -->
	<declare-styleable name="SelectionMenuBehavior">
		<attr name="animTime"/><!-- In animation duration -->
		<attr name="animExitTime"/><!-- Optional out animation duration (if not specified, animTime is used for both enter and exit) -->
	</declare-styleable>
	
	<declare-styleable name="RatingBar">
		<attr name="android:enabled"/>
		<!-- The star drawble to use -->
		<attr name="android:drawable"/>
		<!-- The off version of star drawable -->
		<attr name="drawableOff" format="reference"/>
		<attr name="drawableWidth"/>
		<attr name="drawableHeight"/>
		<attr name="drawableTint"/>
		<!-- The animated background -->
		<attr name="lineBackground"/>
		<!-- Can be left (default) / right. Defines horizontal position for stars within rating bar -->
		<attr name="android:gravity"/>
	</declare-styleable>
	<declare-styleable name="RatingBarSceneParams">
		<attr name="android:background"/>
		<attr name="drawableTint"/>
		<!-- NOTE: limited support for drawable transitions. For new drawable to appear, default scene should have some default drawable set
			 Basically, that means we can transition between drawables, but we can't transition between no-drawable and drawable and vice-versa -->
		<attr name="android:drawable"/>
		<attr name="drawableOff"/>
		<attr name="lineBackground"/>
	</declare-styleable>
	
</resources>